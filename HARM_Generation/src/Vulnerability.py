"""
CREST Project 9: Automated security assessment for interconnected systems
Created by Mengmeng Ge
Modified by Moyang Feng
05/02/2020
This module contains vulnerability class and relevant functions.
"""

from SecurityMetrics import *

import sys
import os

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..','..')))
from HARM_Generation.scripts.llm_utils import generate_postcondition_llm, predict_cvss_vector
from HARM_Generation.scripts.get_vulnerabilities_for_CPE import update_vulnerability_in_tsv
from evaluation.runningBaronLLM import baron_local_generate
from evaluation.runningLLAMA import llama_local_generate



class VulnerabilityNode(object):
    """
    Create vulnerability node object.
    """
    def __init__(self, name):
        # general info
        self.name = name
        self.publishedDate = ''
        self.lastModifiedDate = ''
        self.vendor = []
        self.product = []
        self.type = ''
        self.description = ''

        # CVSS metrics
        self.cvss_vector = ''

        # pre/post conditions
        self.precondition = ''
        self.postcondition = ''

        # all vulnerabilities that are reachable from this vulnerability
        self.connections: list[VulnerabilityNode] = []
    
    def __str__(self):
        return self.name
    
    def construct_vulnerability(self, data, cpe_string):
        self.name = data['ID']
        self.vendor = data['Vendor']
        self.product = data['Product']
        self.description = data['Description']

        # if CVSS vector is not provided, infer it using LLM
        if data.get('CVSS_Vector') and data['CVSS_Vector'].strip():
            self.cvss_vector = data['CVSS_Vector']
        else: 
            self.cvss_vector = self.infer_cvss_vector(llama_local_generate, cpe_string)

        # determine the pre and post conditions 
        self.precondition = self.set_precondition()
        
        # Check if postcondition is already inferred, if not, infer it
        if data.get('Postcondition') and data['Postcondition'].strip():
            self.postcondition = data['Postcondition']
            print(f"Using existing postcondition for {self.name}: {self.postcondition}")
        else:
            self.postcondition = self.set_postcondition(baron_local_generate, cpe_string)

    def printInfo(self):
        if self.description == '':
            print('Vulnerability Node : ', self.name)
            return
        
        print('\n===== %s =====' %self.name)
        print('Vendor:', self.vendor)
        print('Product: ', self.product)
        print('Type: ', self.type)
        print('Description: ', self.description)
        print('Precondition: ', self.precondition)
        print('Postcondition: ', self.postcondition)
        print('CVSS Vector: ', self.cvss_vector)

    def thresholdPri(self, node, t):
        """
        Set start point for the vulnerability network and link vulnerabilities to the start point.
        
        :param node: node in the network which has vulnerabilities
        :param t: privilege value for the start point
        :returns None
        """
        
        node.vul.start = VulnerabilityNode('start')
        start = node.vul.start
        del start.connections[:]

        # loop through vulnerability nodes
        for v in node.vul.nodes:
            if v.privilege <= t:
                start.connections.append(v)
        
        return None
    
    def terminalPri(self, node, t):
        """
        Set end point for the vulnerability network and link vulnerabilities to the end point.
        
        :param node: node in the network which has vulnerabilities
        :param t: privilege value for the end point
        :returns None
        """
        
        node.vul.end = VulnerabilityNode('end')
        end = node.vul.end
        del end.connections[:]

        # loop through vulnerability nodes
        for v in node.vul.nodes:
            if v.privilege >= t:
                v.reachable_vulnerabilities.append(end)
        
        return None
    

    def set_precondition(self):
        """
        Maps Privilege Required from CVSS vector to precondition string.
        
        :returns precondition string
        """
        
        if 'PR:N' in self.cvss_vector:
            return 'None'
        elif 'PR:L' in self.cvss_vector:
            return 'User'
        elif 'PR:H' in self.cvss_vector:
            return 'Root'
        else:
            return 'User'
    
        
    def add_self_to_vulnerability_network(self, vulnerability_network):
        vulnerability_network.nodes.append(self)
        if self.precondition == 'None':
            if self.postcondition == 'Root':
                vulnerability_network.end.connections.append(self)
            else:
                vulnerability_network.start.connections.append(self)
        else: 
            vulnerability_network.start.connections.append(self)
    

    def set_postcondition(self, llm_function, cpe_string):
        """
        Uses AI to assess cvss vector and description to determine
        postcondition privilege gained by an attacker after exploiting the
        vulnerability.

        :param llm_function: LLM function to use (e.g., baron_local_generate)
        :param cpe_string: CPE string used to find the correct vulnerability file
        :returns postcondition string ('None', 'User', or 'Root')
        """
        postcondition = generate_postcondition_llm(self.cvss_vector, self.description, llm_function)
        print(f"Postcondition for {self.name} determined as: {postcondition}")
        
        # Save the inferred postcondition back to the TSV file
        update_vulnerability_in_tsv(self.name, cpe_string, postcondition=postcondition)
        
        return postcondition

    def infer_cvss_vector(self, llm_function, cpe_string):
        """
        Uses AI to infer CVSS vector from vulnerability description.

        :param llm_function: LLM function to use (e.g., baron_local_generate or llama_local_generate)
        :param cpe_string: CPE string used to find the correct vulnerability file
        :returns inferred CVSS vector string
        """

        cvss_vector = predict_cvss_vector(self.description, llm_function)
        print(f"Inferred CVSS vector for {self.name} as: {cvss_vector}")
        
        # Save the inferred CVSS vector back to the TSV file
        update_vulnerability_in_tsv(self.name, cpe_string, cvss_vector=cvss_vector)
        
        return cvss_vector

